/// <reference types="node" />
/// <reference types="node" />
import EventEmitter from 'events';
declare enum ADNLClientState {
    CONNECTING = 0,
    OPEN = 1,
    CLOSING = 2,
    CLOSED = 3
}
interface ADNLClient {
    emit(event: 'connect'): boolean;
    emit(event: 'ready'): boolean;
    emit(event: 'close'): boolean;
    emit(event: 'data', data: Buffer): boolean;
    emit(event: 'error', error: Error): boolean;
    on(event: 'connect', listener: () => void): this;
    on(event: 'ready', listener: () => void): this;
    on(event: 'close', listener: () => void): this;
    on(event: 'data', listener: (data: Buffer) => void): this;
    on(event: 'error', listener: (error: Error, close: boolean) => void): this;
    once(event: 'connect', listener: () => void): this;
    once(event: 'ready', listener: () => void): this;
    once(event: 'close', listener: () => void): this;
    once(event: 'data', listener: (data: Buffer) => void): this;
    once(event: 'error', listener: (error: Error, close: boolean) => void): this;
}
declare class ADNLClient extends EventEmitter {
    protected socket: any;
    protected host: string;
    protected port: number;
    private buffer;
    private address;
    private params;
    private keys;
    private cipher;
    private decipher;
    private _state;
    constructor(socket: any, url: string, peerPublicKey: Uint8Array | string);
    protected get handshake(): Buffer;
    get state(): ADNLClientState;
    protected onBeforeConnect(): Promise<void>;
    protected onConnect(): void;
    protected onReady(): void;
    protected onClose(): void;
    protected onData(data: Buffer): void;
    protected onError(error: Error, close?: boolean): void;
    protected onHandshake(): void;
    write(data: Buffer | Uint8Array): void;
    connect(): Promise<void>;
    end(): void;
    protected encrypt(data: Buffer): Buffer;
    protected decrypt(data: Buffer): Buffer;
}
export { ADNLClient, ADNLClientState };
