"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generate = void 0;
const parseSchema_1 = require("../parser/parseSchema");
const CodeBuilder_1 = require("./CodeBuilder");
const crc = __importStar(require("crc-32"));
const case_shift_1 = require("case-shift");
const BUILT_IN = [
    'false',
    'true',
    'bytes',
    'boolTrue',
    'boolFalse',
    'vector',
    'int128',
    'int256'
];
function normalizeTypeName(name) {
    return name.replaceAll('.', '_');
}
function normalizeFieldName(name) {
    return (0, case_shift_1.snakeToCamel)(name);
}
function getTypeId(src) {
    return crc.str(src
        .replaceAll('(', '')
        .replaceAll(')', ''));
}
function getTypeName(id) {
    if (id.id.name === 'string') {
        return 'TLString';
    }
    if (id.id.name === 'int256') {
        return 'TLInt256';
    }
    if (id.id.name === 'int') {
        return 'TLInt';
    }
    if (id.id.name === 'bytes') {
        return 'TLBytes';
    }
    if (id.id.name === 'long') {
        return 'TLLong';
    }
    if (id.id.name === '#') {
        return 'TLFlag';
    }
    if (id.id.name === 'Bool') {
        return 'TLBool';
    }
    if (id.id.name === 'true') {
        return 'TLBool';
    }
    if (id.id.name === 'false') {
        return 'TLBool';
    }
    return normalizeTypeName(id.id.name);
}
function getEncoderFnForType(id, type) {
    if (type.type === 'ETypeIdentifier') {
        if (type.id.name === 'string') {
            return `encoder.writeString(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === 'int256') {
            return `encoder.writeInt256(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === 'int') {
            return `encoder.writeInt32(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === 'bytes') {
            return `encoder.writeBuffer(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === 'long') {
            return `encoder.writeInt64(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === '#') {
            return `encoder.writeUInt32(src.${normalizeFieldName(id.name)})`;
        }
        if (type.id.name === 'Bool' || type.id.name === 'true' || type.id.name === 'false') {
            return `encoder.writeBool(src.${normalizeFieldName(id.name)})`;
        }
        return `Codecs.${normalizeTypeName(type.id.name)}.encode(src.${normalizeFieldName(id.name)}, encoder)`;
    }
    else if (type.type === 'EExpression') {
        if (type.subexpressions.length !== 2) {
            throw Error('Unsupported');
        }
        if (type.subexpressions[0].type !== 'ETypeIdentifier') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[1].type !== 'ETypeIdentifier') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[0].id.name !== 'vector') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[1].id.name === 'int') {
            return `encoder.writeVector((s, d) => d.writeInt32(s), src.${normalizeFieldName(id.name)})`;
        }
        else if (type.subexpressions[1].id.name === 'int256') {
            return `encoder.writeVector((s, d) => d.writeInt256(s), src.${normalizeFieldName(id.name)})`;
        }
        else {
            return `encoder.writeVector(Codecs.${getTypeName(type.subexpressions[1])}.encode, src.${normalizeFieldName(id.name)})`;
        }
    }
}
function getDecoderFnForType(id, type) {
    if (type.type === 'ETypeIdentifier') {
        if (type.id.name === 'string') {
            return `decoder.readString()`;
        }
        if (type.id.name === 'int256') {
            return `decoder.readInt256()`;
        }
        if (type.id.name === 'int') {
            return `decoder.readInt32()`;
        }
        if (type.id.name === 'bytes') {
            return `decoder.readBuffer()`;
        }
        if (type.id.name === 'long') {
            return `decoder.readInt64()`;
        }
        if (type.id.name === '#') {
            return `decoder.readUInt32()`;
        }
        if (type.id.name === 'Bool' || type.id.name === 'true' || type.id.name === 'false') {
            return `decoder.readBool()`;
        }
        return `Codecs.${normalizeTypeName(type.id.name)}.decode(decoder)`;
    }
    else if (type.type === 'EExpression') {
        if (type.subexpressions.length !== 2) {
            throw Error('Unsupported');
        }
        if (type.subexpressions[0].type !== 'ETypeIdentifier') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[1].type !== 'ETypeIdentifier') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[0].id.name !== 'vector') {
            throw Error('Unsupported');
        }
        if (type.subexpressions[1].id.name === 'int') {
            return `decoder.readVector((d) => d.readInt32())`;
        }
        else if (type.subexpressions[1].id.name === 'int256') {
            return `decoder.readVector((d) => d.readInt256())`;
        }
        else {
            return `decoder.readVector(Codecs.${getTypeName(type.subexpressions[1])}.decode)`;
        }
    }
}
function generateConstructor(decl, typeId) {
    let code = new CodeBuilder_1.CodeBuilder();
    code.add(`export interface ${normalizeTypeName(decl.id.name)} {`);
    code.inTab(() => {
        code.add(`readonly kind: '${decl.id.name}';`);
        for (let field of decl.args) {
            if (field.argType.expression.type === 'ETypeIdentifier') {
                let optional = !!field.conditionalDef;
                if (optional) {
                    code.add(`readonly ${normalizeFieldName(field.id.name)}: ${getTypeName(field.argType.expression)} | null;`);
                }
                else {
                    code.add(`readonly ${normalizeFieldName(field.id.name)}: ${getTypeName(field.argType.expression)};`);
                }
            }
            else if (field.argType.expression.type === 'EExpression') {
                if (field.argType.expression.subexpressions.length !== 2) {
                    throw Error('Unsupported');
                }
                if (field.argType.expression.subexpressions[0].type !== 'ETypeIdentifier') {
                    throw Error('Unsupported');
                }
                if (field.argType.expression.subexpressions[1].type !== 'ETypeIdentifier') {
                    throw Error('Unsupported');
                }
                if (field.argType.expression.subexpressions[0].id.name !== 'vector') {
                    throw Error('Unsupported');
                }
                code.add(`readonly ${normalizeFieldName(field.id.name)}: ${getTypeName(field.argType.expression.subexpressions[1])}[];`);
            }
        }
    });
    code.add('}');
    return code;
}
function generateFunction(constructor, typeId) {
    let code = new CodeBuilder_1.CodeBuilder();
    code.add(`${normalizeTypeName(constructor.id.name)}: {`);
    code.inTab(() => {
        code.add(`encodeRequest: (src: ${normalizeTypeName(constructor.id.name)}, encoder: TLWriteBuffer) => { encoder.writeInt32(${typeId}); Codecs.${normalizeTypeName(constructor.id.name)}.encode(src, encoder); },`);
        if (constructor.resultType.id.name === 'Object') {
            code.add(`decodeResponse: (decoder: TLReadBuffer) => decoder.readObject()`);
        }
        else {
            code.add(`decodeResponse: (decoder: TLReadBuffer) => Codecs.${normalizeTypeName(constructor.resultType.id.name)}.decode(decoder)`);
        }
    });
    if (constructor.resultType.id.name === 'Object') {
        code.add(`} as TLFunction<${normalizeTypeName(constructor.id.name)}, TLBytes>,`);
    }
    else {
        code.add(`} as TLFunction<${normalizeTypeName(constructor.id.name)}, ${normalizeTypeName(constructor.resultType.id.name)}>,`);
    }
    return code;
}
function generateType(name, constructors) {
    let code = new CodeBuilder_1.CodeBuilder();
    code.add(`export type ${name} = ${constructors.map((v) => normalizeTypeName(v.declaration.id.name)).join(' | ')};`);
    return code;
}
function generateConstructorCodec(constructor) {
    let code = new CodeBuilder_1.CodeBuilder();
    code.add(`${normalizeTypeName(constructor.id.name)}: {`);
    code.inTab(() => {
        code.add(`encode: (src: ${normalizeTypeName(constructor.id.name)}, encoder: TLWriteBuffer) => {`);
        code.inTab(() => {
            for (let field of constructor.args) {
                if (field.conditionalDef) {
                    code.add(`(src.${field.conditionalDef.id.name} & (1 << ${field.conditionalDef.nat})) && !!src.${normalizeFieldName(field.id.name)} && ${getEncoderFnForType(field.id, field.argType.expression)};`);
                }
                else {
                    code.add(getEncoderFnForType(field.id, field.argType.expression) + ';');
                }
            }
        });
        code.add('},');
        code.add(`decode: (decoder: TLReadBuffer): ${normalizeTypeName(constructor.id.name)} => {`);
        code.inTab(() => {
            let fs = [];
            for (let field of constructor.args) {
                fs.push(normalizeFieldName(field.id.name));
                if (field.conditionalDef) {
                    code.add(`let ${normalizeFieldName(field.id.name)} = (${field.conditionalDef.id.name} & (1 << ${field.conditionalDef.nat})) ? ` + getDecoderFnForType(field.id, field.argType.expression) + ' : null;');
                }
                else {
                    code.add(`let ${normalizeFieldName(field.id.name)} = ` + getDecoderFnForType(field.id, field.argType.expression) + ';');
                }
            }
            code.add(`return { kind: '${constructor.id.name}', ${fs.join(', ')} };`);
        });
        code.add('},');
    });
    code.add(`} as TLCodec<${normalizeTypeName(constructor.id.name)}>,`);
    return code;
}
function generateTypeCodec(name, constructors) {
    let code = new CodeBuilder_1.CodeBuilder();
    code.add(`${normalizeTypeName(name)}: {`);
    code.inTab(() => {
        code.add(`encode: (src: ${normalizeTypeName(name)}, encoder: TLWriteBuffer) => {`);
        code.inTab(() => {
            code.add(`const kind = src.kind;`);
            for (let t of constructors) {
                code.add(`if (kind === '${t.declaration.id.name}') {`);
                code.inTab(() => {
                    code.add(`encoder.writeInt32(${t.id});`);
                    code.add(`Codecs.${normalizeTypeName(t.declaration.id.name)}.encode(src, encoder);`);
                    code.add(`return;`);
                });
                code.add('}');
            }
            code.add(`throw Error('Unknown type: ' + kind);`);
        });
        code.add('},');
        code.add(`decode: (decoder: TLReadBuffer): ${normalizeTypeName(name)} => {`);
        code.inTab(() => {
            code.add(`const kind = decoder.readInt32();`);
            for (let t of constructors) {
                code.add(`if (kind === ${t.id}) {`);
                code.inTab(() => {
                    code.add(`return Codecs.${normalizeTypeName(t.declaration.id.name)}.decode(decoder);`);
                });
                code.add('}');
            }
            code.add(`throw Error('Unknown type: ' + kind);`);
        });
        code.add('},');
    });
    code.add(`} as TLCodec<${normalizeTypeName(name)}>,`);
    return code;
}
function generate(schema) {
    // Parse
    let srcLines = schema.split(/\n|\r\n/);
    let src = (0, parseSchema_1.parseSchema)(schema);
    // Header
    let code = new CodeBuilder_1.CodeBuilder();
    code.add('import { TLWriteBuffer, TLReadBuffer, TLFlag, TLInt, TLString, TLLong, TLInt256, TLInt128, TLBytes, TLBool, TLCodec, TLFunction } from "ton-tl";');
    code.add();
    // Process declaration
    code.add('//');
    code.add('// Constructors');
    code.add('//');
    code.add();
    let types = new Map();
    for (let declaration of src.constructors.declarations) {
        if (declaration.type === 'CombinatorDeclaration') {
            if (BUILT_IN.includes(declaration.id.name)) {
                continue;
            }
            let declLine = srcLines[declaration.start.line - 1];
            let typeId = getTypeId(declLine.trim().slice(0, -1));
            code.append(generateConstructor(declaration, typeId));
            let name = normalizeTypeName(declaration.resultType.id.name);
            if (types.has(name)) {
                types.get(name).push({ declaration, id: typeId });
            }
            else {
                types.set(name, [{ declaration, id: typeId }]);
            }
        }
        else if (declaration.type === 'BuiltinCombinatorDeclaration') {
            continue; // Ignores built in aliases
        }
        else {
            throw Error('Unknown declaration: ' + declaration.type);
        }
    }
    code.add('//');
    code.add('// Types');
    code.add('//');
    code.add();
    for (let tp of types) {
        code.append(generateType(tp[0], tp[1]));
    }
    code.add('//');
    code.add('// Functions');
    code.add('//');
    code.add();
    // Process functions
    for (let declaration of src.functions.declarations) {
        if (declaration.type === 'CombinatorDeclaration') {
            let declLine = srcLines[declaration.start.line - 1];
            let typeId = getTypeId(declLine.slice(0, -1));
            code.append(generateConstructor(declaration, typeId));
        }
        else {
            throw Error('Unknown declaration: ' + declaration.type);
        }
    }
    code.add();
    code.add('export const Functions = {');
    code.inTab(() => {
        for (let declaration of src.functions.declarations) {
            if (declaration.type === 'CombinatorDeclaration') {
                let declLine = srcLines[declaration.start.line - 1];
                let typeId = getTypeId(declLine.slice(0, -1));
                code.append(generateFunction(declaration, typeId));
            }
            else {
                throw Error('Unknown declaration: ' + declaration.type);
            }
        }
    });
    code.add('};');
    code.add('//');
    code.add('// Codecs');
    code.add('//');
    code.add();
    code.add('export const Codecs = {');
    code.inTab(() => {
        for (let tp of types) {
            for (let t of tp[1]) {
                code.append(generateConstructorCodec(t.declaration));
            }
        }
        for (let declaration of src.functions.declarations) {
            if (declaration.type === 'CombinatorDeclaration') {
                code.append(generateConstructorCodec(declaration));
            }
        }
        for (let tp of types) {
            code.append(generateTypeCodec(tp[0], tp[1]));
        }
    });
    code.add('};');
    return code.render();
}
exports.generate = generate;
