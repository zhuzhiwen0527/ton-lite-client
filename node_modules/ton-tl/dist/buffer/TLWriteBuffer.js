"use strict";
/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TLWriteBuffer = void 0;
const bn_js_1 = require("bn.js");
class TLWriteBuffer {
    #used = 0;
    #buf = Buffer.alloc(128);
    #ensureSize(needBytes) {
        if ((this.#buf.byteLength - this.#used) <= needBytes) {
            this.#buf = Buffer.concat([this.#buf, Buffer.alloc(this.#buf.byteLength)]);
        }
    }
    writeInt32(val) {
        this.#ensureSize(4);
        this.#buf.writeInt32LE(val, this.#used);
        this.#used += 4;
    }
    writeUInt32(val) {
        this.#ensureSize(4);
        this.#buf.writeUInt32LE(val, this.#used);
        this.#used += 4;
    }
    writeInt64(val) {
        let src = new bn_js_1.BN(val, 10);
        let neg = src.isNeg();
        if (neg) {
            src = src.add(new bn_js_1.BN(Buffer.from([0, 0, 0, 0, 0, 0, 0, 128]), 'le'));
        }
        let buf = src.toBuffer('le');
        while (buf.length < 8) {
            buf = Buffer.concat([buf, Buffer.from([0])]);
        }
        if (buf.length > 8) {
            throw new Error('Invalid value');
        }
        if (buf[buf.length - 1] & 128) {
            throw new Error('Invalid value');
        }
        if (neg) {
            buf[buf.length - 1] = buf[buf.length - 1] + 128;
        }
        this.#ensureSize(8);
        this.#buf.set(buf, this.#used);
        this.#used += 8;
    }
    writeUInt8(val) {
        this.#ensureSize(4);
        this.#buf.writeUint8(val, this.#used);
        this.#used++;
    }
    writeInt256(val) {
        this.#ensureSize(256 / 8);
        if (val.byteLength !== 256 / 8) {
            throw new Error('Invalid int256 length');
        }
        for (let byte of val) {
            this.writeUInt8(byte);
        }
    }
    writeBuffer(buf) {
        this.#ensureSize(buf.byteLength + 4);
        let len = 0;
        if (buf.byteLength <= 253) {
            this.writeUInt8(buf.byteLength);
            len += 1;
        }
        else {
            this.writeUInt8(254);
            this.#ensureSize(3);
            this.#buf.writeUintLE(buf.byteLength, this.#used, 3);
            this.#used += 3;
            len += 4;
        }
        for (let byte of buf) {
            this.writeUInt8(byte);
            len += 1;
        }
        while (len % 4 !== 0) {
            this.writeUInt8(0);
            len += 1;
        }
    }
    writeString(src) {
        this.writeBuffer(Buffer.from(src));
    }
    writeBool(src) {
        if (src) {
            this.writeUInt32(0x997275b5);
        }
        else {
            this.writeUInt32(0xbc799737);
        }
    }
    writeVector(codec, data) {
        this.writeUInt32(data.length);
        for (let d of data) {
            codec(d, this);
        }
    }
    build() {
        return this.#buf.slice(0, this.#used);
    }
}
exports.TLWriteBuffer = TLWriteBuffer;
