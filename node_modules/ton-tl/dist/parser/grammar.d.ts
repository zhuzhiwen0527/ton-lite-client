/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
export declare const grammar = "{\n  const makeNode = (type, body = {}) => ({\n    type,\n    ...location(),\n    ...body,\n  })\n\n  const makeFinalDecl = (finalization, id) =>\n    makeNode('FinalDeclaration', { finalization, id })\n\n  const makeDeclarationsNode = (type, declarations, initial = []) =>\n    makeNode(type, {\n      declarations: declarations\n        .filter(e => e.type === type)\n        .reduce((acc, { declarations }) => {\n          acc.push(...declarations)\n          return acc\n        }, initial)\n    })\n\n  // [[a,b],[c,d]] -> [a,c]\n  const extractFirst = list =>\n    list.map(list2 => list2 && list2[0])\n\n  // [[a,b],[c,d]] -> [b,d]\n  const extractLast = list =>\n    list.map(list2 => list2 && list2[list2.length - 1])\n\n  const safeFirst = list => list ? list[0] : null\n  const safeLast = list => list ? list[list.length - 1] : null\n}\n\nStart\n  = __ program:TLProgram __ { return program }\n\n// ---Character classes---\n\nLcLetter\n  = letter:[a-z] { return letter }\n\nUcLetter\n  = letter:[A-Z] { return letter }\n\nDigit\n  = digit:[0-9] { return Number(digit) }\n\nHexDigit\n  = hexDigit:[0-9a-f] { return hexDigit }\n\nLetter = LcLetter / UcLetter\nIdentChar = Letter / Digit / \"_\"\n\n// ---Simple identifiers and keywords---\n\nLcIdent = LcLetter IdentChar* { return text() }\nUcIdent = UcLetter IdentChar* { return text() }\nNamespaceIdent = LcIdent\nLcIdentNs = ((NamespaceIdent \".\")*)? LcIdent { return text() }\nUcIdentNs = ((NamespaceIdent \".\")*)? UcIdent { return text() }\nLcIdentFull =\n  LcIdentNs (\"#\"\n    // 4 - 8 hex digits\n    HexDigit HexDigit HexDigit HexDigit\n    HexDigit? HexDigit? HexDigit? HexDigit?\n  )? { return text() }\n\n// ---Other tokens---\n\nFinalKw  = \"Final\"  !IdentChar\nNewKw    = \"New\"    !IdentChar\nEmptyKw  = \"Empty\"  !IdentChar\n\nNatConst = Digit+ !IdentChar { return Number(text()) }\n\n// ---General syntax of a TL program---\n\nTLProgram\n  = head:ConstrDeclarations tail:(\n      __ \"---\" \"functions\" \"---\" __ FunDeclarations\n      / __ \"---\" \"types\" \"---\" __ ConstrDeclarations\n    )* {\n      const declarations = extractLast(tail)\n      const constructors = makeDeclarationsNode(\n        'ConstructorDeclarations', declarations, head.declarations)\n      const functions = makeDeclarationsNode(\n        'FunctionDeclarations', declarations)\n      return makeNode('TLProgram', {\n        constructors,\n        functions\n      })\n    }\nConstrDeclarations\n  = decls:(Declaration __)*\n    { return makeNode('ConstructorDeclarations', {\n        declarations: extractFirst(decls) }) }\nFunDeclarations\n  = decls:(Declaration __)*\n    { return makeNode('FunctionDeclarations', {\n        declarations: extractFirst(decls) }) }\nDeclaration\n  = FinalDecl\n  / CombinatorDecl\n  / BuiltinCombinatorDecl\n  / PartialAppDecl\n// ---Syntactical categories and constructions---\nENat\n  = value:NatConst\n    { return makeNode('ENat', { value }) }\n// TypeExpr\n//   = expression:Expr\n//     { return makeNode('TypeExpression', { expression }) }\n// NatExpr\n//   = expression:Expr\n//     { return makeNode('NatExpression', { expression }) }\nExpr\n  = subexprs:(__ Subexpr)* {\n      return makeNode('EExpression', {\n        subexpressions: extractLast(subexprs)\n      })\n    }\nSubexpr\n  = Term\n  / natexpr:ENat __ \"+\" __ subexpr:Subexpr {\n      return makeNode('EOperator', {\n        kind: '+',\n        expression: makeNode('EExpression', {\n          subexpressions: [natexpr, subexpr]\n        })\n      })\n    }\n  // / Subexpr \"+\" NatConst\n// Possible infinite loop when parsing\n// (left recursion: Expr -> Subexpr -> Subexpr).\nETypeIdent\n  = id:TypeIdent\n    { return makeNode('ETypeIdentifier', { id }) }\nTerm\n  = \"(\" __ expr:Expr __ \")\" { return expr }\n  // / id:ETypeIdent __ \"<\" __ head:Expr tail:(__ \",\" __ Expr)* __ \">\" {\n  / id:ETypeIdent __ \"<\" __ head:Subexpr tail:(__ \",\" __ Subexpr)* __ \">\" {\n      return makeNode('EExpression', {\n        subexpressions: [id, head].concat(extractLast(tail))\n      })\n    }\n  / ETypeIdent\n  // / VarIdent //?\n  / ENat\n  / \"%\" terms:(__ Term)+ {\n      const subexpressions = extractLast(terms)\n      return makeNode('EOperator', {\n        kind: '%',\n        expression: subexpressions.length > 1\n          ? makeNode('EExpression', { subexpressions })\n          : subexpressions[0]\n      })\n    }\nSimpleTypeIdent\n  = name:LcIdentNs\n    { return makeNode('SimpleTypeIdentifier', { name }) }\nHashTypeIdent\n  = name:\"#\"\n    { return makeNode('HashTypeIdentifier', { name }) }\nTypeIdent\n  = BoxedTypeIdent / SimpleTypeIdent / HashTypeIdent\nBoxedTypeIdent\n  = name:UcIdentNs\n    { return makeNode('BoxedTypeIdentifier', { name }) }\nVarIdent\n  = name:(LcIdent / UcIdent)\n    { return makeNode('VariableIdentifier', { name }) }\nTypeTerm\n  = bang:\"!\"? __ expr:Term {\n      const expression = bang === '!'\n        ? makeNode('EOperator', { kind: '!', expression: expr })\n        : expr\n      return makeNode('TypeExpression', { expression })\n    }\nNatTerm\n  = expression:Term\n    { return makeNode('NatExpression', { expression }) }\n// ---Combinator declarations---\nFullCombName\n  = ident:LcIdentFull {\n      const [name, magic] = ident.split('#')\n      if (!magic) return makeNode('ShortCombinatorName', { name })\n      return makeNode('FullCombinatorName', { name, magic })\n    }\nShortCombName\n  = name:LcIdentNs\n    { return makeNode('ShortCombinatorName', { name }) }\nEmptyCombName\n  = name:\"_\"\n    { return makeNode('EmptyCombinatorName', { name }) }\nVarIdentEmpty\n  = name:\"_\"\n    { return makeNode('EmptyVariableIdentifier', { name }) }\nCombinatorDecl\n  = id:FullCombinatorId __\n    optionalArgs:(OptArgs __)*\n    args:(Args __)*\n    \"=\" __ excl:\"!\"? __\n    resultType:ResultType __ \";\" {\n      return makeNode('CombinatorDeclaration', {\n        id,\n        optionalArgs: [].concat(...extractFirst(optionalArgs)),\n        args: [].concat(...extractFirst(args)),\n        bang: excl === \"!\",\n        resultType\n      })\n    }\nFullCombinatorId\n  = FullCombName / EmptyCombName\nCombinatorId\n  = ShortCombName / EmptyCombName\nOptArgs\n  // = \"{\" ids:(__ VarIdent)+ __ \":\" __ \"!\"? __ type:TypeExpr __ \"}\"\n  = \"{\" ids:(__ VarIdent)+ __ \":\" __ argType:TypeTerm __ \"}\" {\n      return extractLast(ids).map(id =>\n        makeNode('OptionalArgument', { id, argType }))\n    }\nArgs\n  = idOrNull:(VarIdentOpt __ \":\")? __\n    mult:(Multiplicity \"*\")? __\n    \"[\" __ subargs:(__ Args)* __ \"]\" {\n      const id = safeFirst(idOrNull)\n        || makeNode('EmptyVariableIdentifier', { name: '_' })\n      const argType = makeNode('TypeExpression', {\n        expression: makeNode('EMultiArg', {\n          multiplicity: safeFirst(mult),\n          subargs: [].concat(...extractLast(subargs))\n        })\n      })\n      return [makeNode('Argument', {\n        id,\n        conditionalDef: null,\n        argType\n      })]\n    }\n  / id:VarIdentOpt __ \":\" __ cond:ConditionalDef? __ argType:TypeTerm\n    { return [makeNode('Argument', { id, conditionalDef: cond, argType })] }\n  / id:VarIdentOpt __ \":\" __ \"(\" __ cond:ConditionalDef? __ argType:TypeTerm __ \")\"\n    { return [makeNode('Argument', { id, conditionalDef: cond, argType })] }\n  / \"(\" ids:(__ VarIdentOpt)+ __ \":\" __ argType:TypeTerm __ \")\" {\n      return extractLast(ids).map(id =>\n        makeNode('Argument', { id, conditionalDef: null, argType }))\n    }\n  / argType:TypeTerm {\n      return [makeNode('Argument', {\n        id: makeNode('EmptyVariableIdentifier', { name: '_' }),\n        conditionalDef: null,\n        argType\n      })]\n    }\nMultiplicity\n  = NatTerm\nVarIdentOpt\n  = VarIdent / VarIdentEmpty\nConditionalDef\n  = id:VarIdent __ nat:(\".\" NatConst)? __ \"?\" {\n      return makeNode('ConditionalDefinition', {\n        id,\n        nat: safeLast(nat)\n      })\n    }\nResultType\n  = id:BoxedTypeIdent __ \"<\" __ head:Subexpr tail:(__ \",\" __ Subexpr)* __ \">\" {\n      return makeNode('ResultType', {\n        id,\n        expression: makeNode('EExpression', {\n          subexpressions: [head].concat(extractLast(tail))\n        })\n      })\n    }\n  / id:BoxedTypeIdent subexprs:(__ Subexpr)* {\n      return makeNode('ResultType', {\n        id,\n        expression: makeNode('EExpression', {\n          subexpressions: extractLast(subexprs)\n        })\n      })\n    }\nBuiltinCombinatorDecl\n  = id:FullCombinatorId __\n    \"?\" __ \"=\" __\n    result:BoxedTypeIdent __ \";\"\n    { return makeNode('BuiltinCombinatorDeclaration', { id, result }) }\n// ---Partial applications (patterns)---\nPartialAppDecl\n  = PartialTypeAppDecl\n  / PartialCombAppDecl\nPartialTypeAppDecl\n  // = id:BoxedTypeIdent __ \"<\" __ head:Expr tail:(__ \",\" __ Expr)* __ \">\" __ \";\" {\n  = id:BoxedTypeIdent __ \"<\" __ head:Subexpr tail:(__ \",\" __ Subexpr)* __ \">\" __ \";\" {\n      return makeNode('PartialTypeApplicationDeclaration', {\n        id,\n        expression: makeNode('EExpression', {\n          subexpressions: [head].concat(extractLast(tail))\n        })\n      })\n    }\n  / id:BoxedTypeIdent subexprs:(__ Subexpr)+ __ \";\" {\n      return makeNode('PartialTypeApplicationDeclaration', {\n        id,\n        expression: makeNode('EExpression', {\n          subexpressions: extractLast(subexprs)\n        })\n      })\n    }\nPartialCombAppDecl\n  = id:CombinatorId subexprs:(__ Subexpr)+ __ \";\" {\n      return makeNode('PartialCombinatorApplicationDeclaration', {\n        id,\n        expression: makeNode('EExpression', {\n          subexpressions: extractLast(subexprs)\n        })\n      })\n    }\n// ---Type finalization---\nFinalDecl\n  = NewKw __ ident:BoxedTypeIdent __ \";\"\n    { return makeFinalDecl('New', ident) }\n  / FinalKw __ ident:BoxedTypeIdent __ \";\"\n    { return makeFinalDecl('Final', ident) }\n  / EmptyKw __ ident:BoxedTypeIdent __ \";\"\n    { return makeFinalDecl('Empty', ident) }\n// --- ---\nComment\n  = \"//\" comment:[^\\r\\n]* (\"\\n\" / EOF)\n    // { return makeNode('Comment', { value: comment.join('') }) }\n\n// --- ---\n\nWs \"whitespace\"\n  = \" \"\n  / \"\\t\"\n  / \"\\r\"\n  / \"\\n\"\n\n__ \"skip whitespace and comments\"\n  = (Ws / Comment)*\n\n// _ \"one or more whitespace\"\n//   = Ws+\n\nEOF\n  = !.";
